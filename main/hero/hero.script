go.property("speed", 1500)
go.property("max_speed", 800)
go.property("jump", 1000)
go.property("gravity", 2500)
go.property("max_fall_speed", 1500)
go.property("friction", 0.8)

local function reset(self)
	self.velocity = vmath.vector3(0, 0, 0)
	self.correction = vmath.vector3()
	self.ground_contact = false
	self.anim = nil
	self.coins = 0
	go.set_position(self.starting_pos)
	msg.post("#collisionobject", "enable")
	msg.post("/level/coins#coins", "reset")
	msg.post("/coin_counter#coin_counter", "update", {coins = self.coins})
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.movement = 0
	self.starting_pos = go.get_position()
	reset(self)
end

function final(self)
	msg.post(".", "release_input_focus")
end

local function play_anim(self, anim)
	if anim ~= self.anim then
		msg.post("#sprite", "play_animation", {id = hash(anim)})
		self.anim = anim
	end
end

local function update_animation(self)
	if self.velocity.x > 0 then
		play_anim(self, "right")
	elseif self.velocity.x < 0 then
		play_anim(self, "left")
	end
end

local function vector_cap(vec, cap)
	result = vmath.vector3(vec)
	if math.abs(vec.x) > cap.x then
		result.x = vec.x > 0 and cap.x or -cap.x
	end
	if math.abs(vec.y) > cap.y then
		result.y = vec.y > 0 and cap.y or -cap.y
	end
	if math.abs(vec.z) > cap.z then
		result.z = vec.z > 0 and cap.z or -cap.z
	end
	return result
end

function update(self, dt)
	local dv = self.movement * vmath.vector3(self.speed, 0, 0) * dt
	if not self.ground_contact then
		dv = dv + vmath.vector3(0, -self.gravity, 0) * dt
	end

	local v0 = self.velocity
	self.velocity = self.velocity + dv

	if self.movement == 0 then
		func = self.velocity.x >= 0 and math.floor or math.ceil
		self.velocity.x = func(self.velocity.x * self.friction)
	end

	local max_velocity_v = vmath.vector3(self.max_speed, self.max_fall_speed, 0)
	self.velocity = vector_cap(self.velocity, max_velocity_v)
	local dx = (v0 + self.velocity) * dt * 0.5

	-- Apply velocity
	go.set_position(go.get_position() + dx)

	update_animation(self)

	-- Reset volatile state
	self.correction = vmath.vector3()
	self.ground_contact = false
end

-- #region Contact point response handlers
local function handle_geometry(self, message, _)
	local normal = message.normal
	local distance = message.distance

	-- Project the correction vector onto the contact normal
	-- (the correction vector is the 0-vector for the first contact point)
	local proj = vmath.dot(self.correction, normal)

	-- Calculate the compensation
	local comp = (distance - proj) * normal

	-- Add this to the correction
	self.correction = self.correction + comp

	-- Apply the compensation
	go.set_position(go.get_position() + comp)

	-- Check if the normal points enough up to consider the player standing on the ground
	-- (0.7 is roughly equal to 45 degrees deviation from pure vertical direction)
	if normal.y > 0.7 then
		self.ground_contact = true
	end

	-- Project the velocity onto the normal
	proj = vmath.dot(self.velocity, normal)

	-- If the projection is negative, the velocity points toward the contact point
	if proj < 0 then
		-- Remove that component
		self.velocity = self.velocity - proj * normal
	end
end

local function handle_danger(self, message, sender)
	-- TODO implement
	print("DANGER")
	reset(self)
end

local function handle_coin(self, message, sender)
	self.coins = self.coins + 1
	msg.post("/coin_counter", "update", {coins = self.coins})
end

local CONTACT_GROUPS = {
	[hash("geometry")] = handle_geometry,
	[hash("danger")] = handle_danger,
	[hash("coin")] = handle_coin
}
-- #endregion Contact point response handlers

-- #region Message handlers
local function handle_contact_point_response(self, message, sender)
	func = CONTACT_GROUPS[message.group]
	if func then
		func(self, message, sender)
	end
end

local MESSAGES = {
	[hash("contact_point_response")] = handle_contact_point_response
}
-- #endregion Message handlers

function on_message(self, message_id, message, sender)
	func = MESSAGES[message_id]
	if func then
		func(self, message, sender)
	end
end

-- #region Input handlers
local function handle_jump(self, action)
	if action.pressed and self.ground_contact then
		self.velocity = self.velocity + vmath.vector3(0, self.jump, 0)
	elseif action.released and self.velocity.y > 0 then
		local damper = 0.5
		self.velocity.y = self.velocity.y * damper
	end
end

local function handle_left(self, action)
	if action.pressed then
		self.movement = self.movement - 1
	elseif action.released then
		self.movement = self.movement + 1
	end
end

local function handle_right(self, action)
	if action.pressed then
		self.movement = self.movement + 1
	elseif action.released then
		self.movement = self.movement - 1
	end
end

local function handle_up(self, action)
	-- TODO implement
end

local function handle_down(self, action)
	-- TODO implement
end

local INPUTS = {
	[hash("jump")] = handle_jump,
	[hash("left")] = handle_left,
	[hash("right")] = handle_right,
	[hash("up")] = handle_up,
	[hash("down")] = handle_down
}
-- #endregion Input handlers

function on_input(self, action_id, action)
	func = INPUTS[action_id]
	if func then
		func(self, action)
	end
end
