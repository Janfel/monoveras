local GRAVITY_V = vmath.vector3(0, -2500, 0)
local JUMP_V = vmath.vector3(0, 1300, 0)
local SPEED = 1000
local FRICTION = 0.8
local MAX_MOVEMENT_V = vmath.vector3(500, 1500, 0)

local function reset(self)
	self.velocity = vmath.vector3(0, 0, 0)
	self.correction = vmath.vector3()
	self.ground_contact = false
	self.anim = nil
	self.coins = 0
	go.set_position(self.starting_pos)
	msg.post("#collisionobject", "enable")
	msg.post("/level/coins#coins", "reset")
	msg.post("/coin_counter#coin_counter", "update", {coins = self.coins})
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.movement = 0
	self.starting_pos = go.get_position()
	reset(self)
end

function final(self)
	msg.post(".", "release_input_focus")
end

local function update_animation(self)
	-- TODO implement
end

local function vector_cap(vec, cap)
	result = vmath.vector3(vec)
	if math.abs(vec.x) > cap.x then
		result.x = vec.x > 0 and cap.x or -cap.x
	end
	if math.abs(vec.y) > cap.y then
		result.y = vec.y > 0 and cap.y or -cap.y
	end
	if math.abs(vec.z) > cap.z then
		result.z = vec.z > 0 and cap.z or -cap.z
	end
	return result
end

function update(self, dt)
	local dv = self.movement * vmath.vector3(SPEED, 0, 0) * dt
	if not self.ground_contact then
		dv = dv + GRAVITY_V * dt
	end

	local v0 = self.velocity
	self.velocity = self.velocity + dv

	if self.movement == 0 then
		self.velocity.x = math.floor(self.velocity.x * FRICTION)
	end

	self.velocity = vector_cap(self.velocity, MAX_MOVEMENT_V)
	local dx = (v0 + self.velocity) * dt * 0.5

	-- Apply velocity
	go.set_position(go.get_position() + dx)

	update_animation(self)

	-- Reset volatile state
	self.correction = vmath.vector3()
	self.ground_contact = false
end

-- #region Contact point response handlers
local function handle_geometry(self, message, _)
	local normal = message.normal
	local distance = message.distance

	-- Project the correction vector onto the contact normal
	-- (the correction vector is the 0-vector for the first contact point)
	local proj = vmath.dot(self.correction, normal)

	-- Calculate the compensation
	local comp = (distance - proj) * normal

	-- Add this to the correction
	self.correction = self.correction + comp

	-- Apply the compensation
	go.set_position(go.get_position() + comp)

	-- Check if the normal points enough up to consider the player standing on the ground
	-- (0.7 is roughly equal to 45 degrees deviation from pure vertical direction)
	if normal.y > 0.7 then
		self.ground_contact = true
	end

	-- Project the velocity onto the normal
	proj = vmath.dot(self.velocity, normal)

	-- If the projection is negative, the velocity points toward the contact point
	if proj < 0 then
		-- Remove that component
		self.velocity = self.velocity - proj * normal
	end
end

local function handle_danger(self, message, sender)
	-- TODO implement
	print("DANGER")
	reset(self)
end

local function handle_coin(self, message, sender)
	self.coins = self.coins + 1
	msg.post("/coin_counter", "update", {coins = self.coins})
end

local CONTACT_GROUPS = {
	[hash("geometry")] = handle_geometry,
	[hash("danger")] = handle_danger,
	[hash("coin")] = handle_coin
}
-- #endregion Contact point response handlers

-- #region Message handlers
local function handle_contact_point_response(self, message, sender)
	func = CONTACT_GROUPS[message.group]
	if func then
		func(self, message, sender)
	end
end

local MESSAGES = {
	[hash("contact_point_response")] = handle_contact_point_response
}
-- #endregion Message handlers

function on_message(self, message_id, message, sender)
	func = MESSAGES[message_id]
	if func then
		func(self, message, sender)
	end
end

-- #region Input handlers
local function handle_jump(self, action)
	if action.pressed and self.ground_contact then
		self.velocity = self.velocity + JUMP_V
	elseif action.released and self.velocity.y > 0 then
		local damper = 0.5
		self.velocity.y = self.velocity.y * damper
	end
end

local function handle_left(self, action)
	if action.pressed then
		self.movement = self.movement - 1
	elseif action.released then
		self.movement = self.movement + 1
	end
end

local function handle_right(self, action)
	if action.pressed then
		self.movement = self.movement + 1
	elseif action.released then
		self.movement = self.movement - 1
	end
end

local function handle_up(self, action)
	-- TODO implement
end

local function handle_down(self, action)
	-- TODO implement
end

local INPUTS = {
	[hash("jump")] = handle_jump,
	[hash("left")] = handle_left,
	[hash("right")] = handle_right,
	[hash("up")] = handle_up,
	[hash("down")] = handle_down
}
-- #endregion Input handlers

function on_input(self, action_id, action)
	func = INPUTS[action_id]
	if func then
		func(self, action)
	end
end
