local gravity_v = vmath.vector3(0, -40, 0)
local jump_v = vmath.vector3(0, 1300, 0)

local function reset(self)
	self.velocity = vmath.vector3(0, 0, 0)
	self.correction = vmath.vector3()
	self.ground_contact = false
	self.anim = nil
	msg.post("#collisionobject", "enable")
end

function init(self)
	reset(self)
end

function final(self)
	-- Add finalization code here
	-- Remove this function if not needed
end

local function update_animation(self)
	-- TODO implement
end

function update(self, dt)
	if not self.ground_contact then
		self.velocity = self.velocity + gravity_v
	end

	-- Apply velocity
	go.set_position(go.get_position() + self.velocity * dt)

	update_animation(self)

	-- Reset volatile state
	self.correction = vmath.vector3()
	self.ground_contact = false
end

-- #region Contact point response handlers
local function handle_geometry(self, message, _)
	local normal = message.normal
	local distance = message.distance

	-- Project the correction vector onto the contact normal
	-- (the correction vector is the 0-vector for the first contact point)
	local proj = vmath.dot(self.correction, normal)

	-- Calculate the compensation
	local comp = (distance - proj) * normal

	-- Add this to the correction
	self.correction = self.correction + comp

	-- Apply the compensation
	go.set_position(go.get_position() + comp)

	-- Check if the normal points enough up to consider the player standing on the ground
	-- (0.7 is roughly equal to 45 degrees deviation from pure vertical direction)
	if normal.y > 0.7 then
		self.ground_contact = true
	end

	-- Project the velocity onto the normal
	proj = vmath.dot(self.velocity, normal)

	-- If the projection is negative, the velocity points toward the contact point
	if proj < 0 then
		-- Remove that component
		self.velocity = self.velocity - proj * normal
	end
end

local function handle_danger(self, message, sender)
	-- TODO implement
end

local contact_groups = {
	[hash("geometry")] = handle_geometry,
	[hash("danger")] = handle_danger
}
-- #endregion Contact point response handlers

-- #region Message handlers
local function handle_contact_point_response(self, message, sender)
	func = contact_groups[message.group]
	if func then
		func(self, message, sender)
	end
end

local function handle_jump(self, message, sender)
	if message.pressed and self.ground_contact then
		self.velocity = self.velocity + jump_v
	elseif message.released and self.velocity.y > 0 then
		self.velocity.y = self.velocity.y * 0.5
	end
end

local function handle_left(self, message, sender)
	-- TODO implement
end

local function handle_right(self, message, sender)
	-- TODO implement
end

local function handle_up(self, message, sender)
	-- TODO implement
end

local function handle_down(self, message, sender)
	-- TODO implement
end

local messages = {
	[hash("contact_point_response")] = handle_contact_point_response,
	[hash("jump")] = handle_jump,
	[hash("left")] = handle_left,
	[hash("right")] = handle_right,
	[hash("up")] = handle_up,
	[hash("down")] = handle_down,
}
-- #endregion Message handlers

function on_message(self, message_id, message, sender)
	func = messages[message_id]
	if func then
		func(self, message, sender)
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end
